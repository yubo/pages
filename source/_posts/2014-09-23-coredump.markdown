---
layout: post
title: "Coredump信息收集"
date: 2014-09-23 21:41:13 +0800
comments: true
categories:
---

### 简介
---
进程的coredump文件较大,出现问题后收集起来比较费事.本文介绍一种轻量级的办法,先将core文件里的关键debug信息打印出来,后续可以非常方便的传到日志服务器中,然后可以在服务器上通过debuginfo文件还原成有用的信息

### 需要准备的软件
---
* [cortex]
* addr2line
* gcc等


### 例子
---

##### 先编译一个会crash的文件

`gcc -g -o a a.c`
```
/* a.c */
#include <stdio.h>
void foo(char *p)
{
	int *crash = NULL;
	*crash = 1;
}
int main(int argc, char ** argv)
{
	char *p = "hello world";
	foo(p);
	return 0;
}
```

##### 保存下debug文件

`objcopy --only-keep-debug a a.debug`

##### release版本去掉debug信息

`strip -g a`

##### 运行产生core文件,确保linux内核开启了ELF_CORE选项，

`ulimit -c unlimited && ./a`

##### 导出core信息，core文件可能在不同的位置，可查看(/proc/sys/kernel/core_pattern)

```
[yubo@yubo990:~/programe/c/gdb]$cortex -i core  -f reg,cal

8<--------------------------------------------------------------------------
  rax:0x0000000000000000  rbx:0x0000000000000000  rcx:0x0000000000400500  rdx:0x0000000019F3ACF8
  rbp:0x0000000019F3ABD0  rsp:0x0000000019F3ABD0  rsi:0x0000000019F3ACE8  rdi:0x00000000004005EC
  rip:0x00000000004004C8  r8:0x0000000000400590  r9:0x0000000067D72740  r10:0x0000000019F3AA60
  r11:0x00000000679C5680  r12:0x00000000004003D0  r13:0x0000000019F3ACE0  r14:0x0000000000000000
  r15:0x0000000000000000  cs:0x0000000000000033  ss:0x000000000000002B  orig_rax :0x00000000FFFFFFFF
  eflags:0x0000000000010202
Call trace:
  #0 at 0x00000000004004c8
  #0 at 0x00000000004004f3 in <main>
```


##### 还原成文件行

```
[yubo@yubo990:~/programe/c/gdb]$addr2line  -e a.debug  0x00000000004004c8 0x00000000004004f3
/home/yubo/programe/c/gdb/a.c:6
/home/yubo/programe/c/gdb/a.c:12
```


### 资源
---
* [cortex]


[cortex]: https://code.google.com/p/cortex-tool/downloads/list  "cortex"